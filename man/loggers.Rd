% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loggers.R
\name{loggers}
\alias{loggers}
\alias{logging}
\alias{null_logger}
\alias{create_file_logger}
\title{App Logging}
\usage{
null_logger(event, message, request = NULL, ...)

create_file_logger(file)
}
\arguments{
\item{event}{A string giving the type of event}

\item{message}{A string describing the particular event in detail}

\item{request}{either \code{NULL} or a \code{Request} object associated with the log}

\item{...}{Additional information passed on from the \code{log()} method}

\item{file}{A file or connection to write to}
}
\description{
\code{fiery} has a build in logging mechanism that lets you capture event
information however you like. Every user-injested warnings and errors are
automatically captured by the logger along with most system errors as well.
\code{fiery} tries very hard not to break due to faulty app logic. This means that
any event handler error will be converted to an error log without \code{fiery}
stopping. In the case of request handlers a 500L response will be send back
if any error is encountered.
}
\section{Setting a logger}{

By default, \code{fiery} uses \code{null_logger} which forwards warning and error
messages to \code{stderr()} and ignores any other logging events. To change this
behavior, set a different logger using the \code{set_logger()} method:\preformatted{app$set_logger(logger)
}

where \code{logger} is a function taking at least the following arguments: \code{event},
\code{message}, \code{request}, and \code{...}.

\code{fiery} comes with one additional logger, which writes all logs to a file. A
new instance of the file logger can be created with
\code{create_file_logger(file)}:\preformatted{app$set_logger(create_file_logger('fiery_log.log'))
}
}

\section{Automatic logs}{

\code{fiery} logs a number of different information by itself describing its
operations during run. The following events are send to the log:

\describe{
\item{\emph{start}}{Will be send when the server starts up}
\item{\emph{resume}}{Will be send when the server is resumed}
\item{\emph{stop}}{Will be send when the server stops}
\item{\emph{request}}{Will be send when a request has been handled. The message
will contain information about how long time it took to handle the request
or if it was denied.}
\item{\emph{websocket}}{Will be send every time a WebSocket connection is
established or closed.}
\item{\emph{message}}{Will be send every time a WebSocket message is received or
send}
\item{\emph{warning}}{Will be send everytime a warning is emitted by an event
handler or delayed execution handler}
\item{\emph{error}}{Will be send everytime an error is signaled by an event
handler or delayed execution handler. In addition some internal functions
will also emit error event when exceptions are encountered}
}

By default only \emph{warning} and \emph{error} events will be logged by sending them
to the error stream.
}

\section{Custom logs}{

Apart from the standard logs described above it is also possible to send
messages to the log as you please, e.g. inside event handlers. This is done
through the \code{log()} method where you at the very least specify an event and a
message. In general it is better to send messages through \code{log()} rather than
with \code{warning()} and \code{stop()} even though the latters will eventually be
caught, as it gives you more control over the logging and what should happen
in the case of an exception.

An example of using \code{log()} in a handler could be:\preformatted{app$on('header', function(server, id, request) {
  server$log('info', paste0('request from ', id, ' received'), request)
})
}

Which would log the timepoint the headers of a request has been recieved.
}

