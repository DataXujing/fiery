% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Fire.R
\docType{class}
\name{Fire}
\alias{Fire}
\title{Generate a New App Object}
\description{
The Fire generator creates a new 'Fire'-object, which is the class containing 
all the app logic. The class is based on the R6 OO-system and is thus
reference-based with methods and data attached to each object, in contrast to
the more well known S3 and S4 systems.
}
\section{Initialization}{

A new 'Fire'-object is initialized using the \code{new()} method on the 
generator:

\strong{Usage}
\tabular{l}{
 \code{app <- Fire$new(host = '127.0.0.1', port = 8080L)}
}

\strong{Arguments}
\tabular{lll}{
 \code{host} \tab  \tab A string overriding the default host (see the Fields section below)\cr
 \code{port} \tab  \tab An integer overriding the default port (see the Fields section below)
}

\emph{Copying}

As 'Fire' objects are using reference semantics new copies of an app cannot
be made simply be assigning it to a new variable. If a true copy of a 'Fire'
object is desired, use the \code{clone()} method.
}

\section{Fields}{

\describe{
 \item{\code{host}}{A string giving a valid IPv4 address owned by the server, or '0.0.0.0' to listen on all addresses. The default is '127.0.0.1'}
 \item{\code{port}}{An integer giving the port number the server should listen on (defaults to 8080L)}
 \item{\code{refreshRate}}{The interval in seconds between run cycles when running a blocking server (defaults to 0.001)}
 \item{\code{refreshRateNB}}{The interval in seconds between run cycles when running a non-bocking server (defaults to 1)}
 \item{\code{triggerDir}}{A valid folder where trigger files can be put when running a blocking server (defaults to NULL)}
 \item{\code{plugins}}{A named list of the already attached plugins. Static - can only be modified using the \code{attach()} method.}
 \item{\code{root}}{The location of the app. Setting this will remove the root value from requests (or decline them with 400 if the request does not match the root). E.g. the path of a request will be changed from /demo/test to /test if \code{root = '/demo'}}
}
}

\section{Methods}{

\describe{
 \item{\code{ignite(block = TRUE, showcase = FALSE, ...)}}{Begins the server,either blocking the console if \code{block = TRUE} or not. If \code{showcase = TRUE} a browser window is opened directing at the server address. \code{...} will be redirected to the 'start' handler(s)}
 \item{\code{start(block = TRUE, showcase = FALSE, ...)}}{A less dramatic synonym of for \code{ignite}}
 \item{\code{reignite(block = TRUE, showcase = FALSE, ...)}}{As \code{ignite} but additionally triggers the 'resume' event after the 'start' event}
 \item{\code{resume(block = TRUE, showcase = FALSE, ...)}}{Another less dramatic synonym, this time for reignite}
 \item{\code{extinguish()}}{Stops a running server}
 \item{\code{stop()}}{Boring synonym for \code{extinguish}}
 \item{\code{on(event, handler, pos = NULL)}}{Add a handler function to to an event at the given position in the handler stack. Returns a string uniquely identifying the handler}
 \item{\code{off(handlerId)}}{Remove the handler tied to the given id}
 \item{\code{trigger(event, ...)}}{Triggers an event passing the additional arguments to the potential handlers}
 \item{\code{send(message, id)}}{Sends a websocket message to the client with the given id, or to all connected clients if id is missing}
 \item{\code{close_ws_con(id)}}{Closes the websocket connection started from the client with the given id, firing the websocket-closed event}
 \item{\code{attach(plugin, ..., force = FALSE)}}{Attaches a plugin to the server. A plugin is an R6 object with an \code{on_attach} method and a \code{name} and \code{require} field. Plugins can only get attached once unless \code{force = TRUE}}
 \item{\code{has_plugin(name)}}{Check whether a plugin with the given name has been attached}
 \item{\code{header(name, value)}}{Add a global header to the server that will be set on all responses}
 \item{\code{set_data(name, value)}}{Adds data to the servers internal data store}
 \item{\code{get_data(name)}}{Extracts data from the internal data store}
 \item{\code{remove_data(name)}}{Removes the data with the given name from the internal data store}
 \item{\code{time(expr, then, after, loop = FALSE)}}{Add a timed evaluation that will be evaluated after the given number of seconds, potentially repeating if loop=TRUE. After the expression has evaluated the 'then' function will get called with the result of the expression and the server object as arguments.}
 \item{\code{remove_time(id)}}{Removes the timed evaluation identified by the id (returned when adding the evaulation)}
 \item{\code{delay(expr, then)}}{As time except the expr is evaluated immediately at the end of the loop cycle}
 \item{\code{remove_delay(id)}}{Removes the delayed evaluation identified by the id}
 \item{\code{async(expr, then)}}{As delay and time except the expression is evaluated asynchronously. The progress of evaluation is checked at the end of each loop cycle}
 \item{\code{remove_async(id)}}{Removes the async evaluation identified by the id. The evaluation is not necessarily stopped but the then function will not get called.}
 \item{\code{set_client_id_converter(converter)}}{Sets the function that converts an HTTP request into a specific client id}
 \item{\code{clone()}}{Create a copy of the full 'Fire' object and return that}
}
}

\section{Events}{

fiery is using an event-based model to allow you to program the logic. During
the lifecycle of an app a range of different events will be triggered and it
is possible to add event handlers to these using the \code{on()} method. An 
event handler is simply a function that will get called every time an event 
is fired. Apart from the predefined lifecycle events it is also possible to 
trigger custom events using the \code{trigger()} method. Manual triggering of
lifecycle events is not allowed.

Following is a list of all lifecycle events:

\describe{
 \item{start}{Will trigger once when the app is started but before it is 
 running. The handlers will recieve the app itself as the \code{server} 
 argument as well as any argument passed on from the \code{ignite()} method. 
 Any return value is discarded.}
 \item{resume}{Will trigger once after the start event if the app has been
 started using the \code{reignite()} method. The handlers will recieve the 
 app itself as the \code{server} argument as well as any argument passed on 
 from the \code{reignite()} method. Any return value is discarded.}
 \item{end}{Will trigger once after the app is stopped. The handlers will 
 recieve the app itself as the \code{server} argument. Any return value is 
 discarded.}
 \item{cycle-start}{Will trigger in the beginning of each loop, before the 
 request queue is flushed. The handlers will recieve the app itself as the 
 \code{server} argument. Any return value is discarded.}
 \item{cycle-end}{Will trigger in the end of each loop, after the 
 request queue is flushed and all delayed, timed, and asynchronous calls have
 been executed. The handlers will recieve the app itself as the \code{server} 
 argument. Any return value is discarded.}
 \item{header}{Will trigger everytime the header of a request is recieved. 
 The return value of the last called handler is used to determine if further
 processing of the request will be done. If the return value is \code{TRUE}
 the request will continue on to normal processing. If the return value is 
 FALSE the response will be send back and the connection will be closed 
 without retrieving the payload. The handlers will recieve the app itself as 
 the \code{server} argument, the client id as the \code{id} argument and the 
 request object as the \code{request} argument}
 \item{before-request}{Will trigger prior to handling of a request (that is, 
 every time a request is recieved unless it is short-circuited by the header
 handlers). The return values of the handlers will be passed on to the request
 handlers and can thus be used to inject data into the request handlers (e.g.
 session specific data). The handlers will recieve the app itself as the 
 \code{server} argument, the client id as the \code{id} argument and the 
 request object as the \code{request} argument}
 \item{request}{Will trigger after the before-request event. This is where 
 the main request handling is done. The return value of the last handler is
 send back to the client as response. If no handler is reqistered a 404 error
 is returned automatically. If the return value is not a valid response,
 a 500 server error is returned instead. The handlers will recieve the app 
 itself as the \code{server} argument, the client id as the \code{id} 
 argument, the request object as the \code{request} argument, and the list of 
 values created by the before-event handlers as the \code{arg_list} argument.}
 \item{after-request}{Will trigger after the request event. This can be used
 to inspect the response (but not modify it) before it is send to the client. 
 The handlers will recieve the app itself as the \code{server} argument, the 
 client id as the \code{id} argument, the request object as the 
 \code{request} argument, and the response as the \code{response} argument. 
 Any return value is discarded.}
 \item{before-message}{This event is triggered when a websocket message is
 recieved. As with the before-request event the return values of the handlers
 are passed on to the message handlers. Specifically if a 'binary' and 
 'message' value is returned they will override the original values in the
 message and after-message handler arguments. This can e.g. be used to decode 
 the message once before passing it through the message handlers. The 
 before-message handlers will recieve the app itself as the \code{server} 
 argument, the client id as the \code{id} argument, a flag indicating whether 
 the message is binary as the \code{binary} argument, the message itself as 
 the \code{message} argument, and the request object used to establish the 
 connection with the client as the \code{request} argument.}
 \item{message}{This event is triggered after the before-message event and is
 used for the primary websocket message handling. As with the request event,
 the handlers for the message event recieves the return values from the 
 before-message handlers which can be used to e.g. inject session specific
 data. The message handlers will recieve the app itself as the \code{server} 
 argument, the client id as the \code{id} argument, a flag indicating whether 
 the message is binary as the \code{binary} argument, the message itself as 
 the \code{message} argument, the request object used to establish the 
 connection with the client as the \code{request} argument, and the values
 returned by the before-message handlers as the \code{arg_list} argument. 
 Contrary to the request event the return values of the handlers are ignored
 as websocket communication is bidirectional}
 \item{after-message}{This event is triggered after the message event. It is
 provided more as an equivalent to the after-request event than out of 
 necessity as there is no final response to inspect and handler can thus just
 as well be atached to the message event. For clear division of server logic 
 message specific handlers should be attached to the message event, whereas 
 general handlers should, if possible, be attached to the after-message 
 event. The after-message handlers will recieve the app itself as the 
 \code{server} argument, the client id as the \code{id} argument, a flag 
 indicating whether the message is binary as the \code{binary} argument, the 
 message itself as the \code{message} argument, and the request object used 
 to establish the connection with the client as the \code{request} argument.}
 \item{send}{This event is triggered after a websocket message is send to a 
 client. The handlers will recieve the app itself as the \code{server} 
 argument, the client id as the \code{id} argument and the send message as 
 the \code{message} argument. Any return value is discarded.}
 \item{websocket-closed}{This event will be triggered every time a websocket
 connection is closed. The handlers will recieve the app itself as the 
 \code{server} argument, the client id as the \code{id} argument and request
 used to establish the closed connection as the \code{request} argument. Any 
 return value is discarded.}
}
}

\examples{
# Create a New App
app <- Fire$new(port = 4689)

# Setup the data everytime it starts
app$on('start', function(server, ...) {
    server$set_data('visits', 0)
    server$set_data('cycles', 0)
})

# Count the number of cycles
app$on('cycle-start', function(server, ...) {
    server$set_data('cycles', server$get_data('cycles') + 1)
})

# Count the number of requests
app$on('before-request', function(server, ...) {
    server$set_data('visits', server$get_data('visits') + 1)
})

# Handle requests
app$on('request', function(server, ...) {
    list(
        status = 200L,
        headers = list('Content-Type' = 'text/html'),
        body = paste('This is indeed a test. You are number', server$get_data('visits'))
    )
})

# Show number of requests in the console
app$on('after-request', function(server, ...) {
    message(server$get_data('visits'))
    flush.console()
})

# Terminate the server after 300 cycles
app$on('cycle-end', function(server, ...) {
    if (server$get_data('cycles') > 300) {
        message('Ending...')
        flush.console()
        server$extinguish()
    }
})

# Be polite
app$on('end', function(server) {
    message('Goodbye')
    flush.console()
})

\dontrun{
app$ignite(showcase = TRUE)
}

}
\keyword{datasets}
